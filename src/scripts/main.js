console.log("This is all working fine and dandy-like.")

const metals = [
    { metal: "Sterling Silver", price: 12.42 },
    { metal: "14K Gold", price: 736.4 },
    { metal: "24K Gold", price: 1258.9 },
    { metal: "Platinum", price: 795.45 },
    { metal: "Palladium", price: 1241.0 }
]

const diamonds = [
    { carets: 0.5, price: 405 },
    { carets: 0.75, price: 782 },
    { carets: 1, price: 1470 },
    { carets: 1.5, price: 1997 },
    { carets: 2, price: 3638 }
]

const ringStyles = [
    { style: "Classic", price: 500 },
    { style: "Modern", price: 710 },
    { style: "Vintage", price: 965 }
]
// Now that you have some raw data, you need to combine the different materials together to produce a new ring. You decide that you need a function whose job is solely to take in all the different parameters and return a new object that represents the custom ring to be made, with a final price on it.

// If the customer wants a modern 1-carat diamond ring made from 24K gold, then the final object would have the following structure.

// {
//     style: "Modern",
//     carets: 1,
//     metal: "24K gold",
//     price: 3438.9
// }

// This is a perfect example of a factory function. It's just a regular function that can take input, and it returns an object. Factory functions tend to start with the word create, so you can define one for creating custom ring orders.

const createCustomRing = (style, carets, metal) => {
    return {
        style: style.style,
        carets: carets.carets,
        metal: metal.metal,
        price: metal.price + style.price + carets.price
    }
}

// Now when a customer places an order, and you want to build an HTML component to represent that order, you can use this new object generated by the factory function to do that.

const newRingOrder = createCustomRing(ringStyles[1], diamonds[2], metals[2])
console.log(newRingOrder)
// Then add order to customer's shopping cart

